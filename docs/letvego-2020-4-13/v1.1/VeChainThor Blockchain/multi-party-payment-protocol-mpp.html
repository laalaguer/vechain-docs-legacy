

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>&lt;no title&gt; &mdash; VeChain Documentation Legacy 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> VeChain Documentation Legacy
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul class="simple">
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">VeChain Documentation Legacy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
      <li>&lt;no title&gt;</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/letvego-2020-4-13/v1.1/VeChainThor Blockchain/multi-party-payment-protocol-mpp.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>—
title: “Multi-party Payment Protocol (MPP)”
slug: “multi-party-payment-protocol-mpp”
hidden: false
createdAt: “2019-02-22T02:11:00.082Z”
updatedAt: “2019-04-30T03:01:01.582Z”
—
One of the major obstacles for ordinary people, or even enterprises, to adopt a public blockchain is the uncertainty and complexity in dealing with crypto assets. On one hand, users have to face the high price volatility when acquiring crypto from the market; on the other hand, they need to understand related concepts and get familiar with various tools to be able to use, manage, store, and secure their crypto assets.</p>
<p>Can we find a way around the above-mentioned difficulties? For the existing blockchain networks such as Bitcoin and Ethereum, the answer is most likely negative. This is due to the fact that for those systems transaction fees must be paid by whomever sends the transaction and sending transactions is the way to interact with a public blockchain.</p>
<p>In VeChainThor, we came up with the multi-party payment protocol (MPP) to tackle this problem. Basically, MPP says that transaction fees can be paid by someone other than who sends the transaction if certain conditions are met. In this way, users can interact with VeChainThor without holding any crypto-assets.</p>
<p>Let us first define the terminology to be used to describe MPP as follows:</p>
<ul class="simple">
<li><em>Sender</em> - account that signs the transaction;</li>
<li><em>Recipient</em> - account to which the transaction is sent;</li>
<li><em>Sponsor</em> - account that sponsors the recipient to pay for the transaction fee;</li>
<li><em>User</em> - VeChainTor allows any account to register other accounts as its users and conditionally pay for the cost of the transactions sent them;</li>
<li><em>Credit</em> - available VHTO for paying for transaction cost for a particular user of a particular account.</li>
</ul>
<p>![](<a class="reference external" href="https://files.readme.io/d5f9847-MPP.png">https://files.readme.io/d5f9847-MPP.png</a>)</p>
<p>The above figure shows the decision-making flow within MPP. When it comes to the question of who should pay for a transaction, VeChainThor first checks the usership and sponsorship associated with the <em>Sender</em> and <em>Recipient</em>. It then tries to deduct the transaction fee from the corresponding account. For instance, if both the usership and sponsorship are in place, the system will first try to deduct the transaction fee from the <em>Sponsor</em>’s balance; if it fails, then from the <em>Recipient</em>’s balance; and if it fails again, from the <em>Sender</em>’s balance.</p>
<p>In practice, a dApp is most likely built upon multiple smart contracts deployed on VeChainThor. Its users interact with our public blockchain through sending transactions to the smart contracts to call a certain function. With MPP, the dApp owner can register its users’ accounts as the <em>User</em> of the smart contracts such that all the legit transactions from the dApp users can be paid by the owner. In this way, people can use the dApp almost in the same way they use other apps without dealing with crypto. Moreover, the owner can set up a single account to sponsor all related smart contracts, which makes the maintenance a lot easier.
[block:api-header]
{</p>
<blockquote>
<div>“title”: “Credit Plan”</div></blockquote>
<p>}
[/block]
To prevent MPP from being abused by malicious users, the owner of a smart contract can set a credit plan for the contract to set up rules on how to pay for the transactions from users. In particular, a credit plan can be defined as:
[block:code]
{</p>
<blockquote>
<div><dl class="docutils">
<dt>“codes”: [</dt>
<dd><dl class="first docutils">
<dt>{</dt>
<dd>“code”: “type creditPlan struct {ntCredit       <a href="#id1"><span class="problematic" id="id2">*</span></a>big.IntntRecoveryRate <a href="#id3"><span class="problematic" id="id4">*</span></a>big.Intn}”,
“language”: “text”</dd>
</dl>
<p class="last">}</p>
</dd>
</dl>
<p>]</p>
</div></blockquote>
<p>}
[/block]
where <cite>RecoveryRate</cite> is the amount of VTHO (in wei) accumulated per block to pay for transactions for each user and <cite>Credit</cite> the maximum amount of VTHO (in wei) that can be accumulated.</p>
<p>When the system checks whether an account’s user has a sufficient amount of credit to pay for the transaction, it calculates the available credit <strong>*c*</strong> as:</p>
<p>![](<a class="reference external" href="https://files.readme.io/08306f9-c_formula.PNG">https://files.readme.io/08306f9-c_formula.PNG</a>)</p>
<p>where <strong>*C*</strong> denotes <cite>Credit</cite>, <strong>*r*</strong> <cite>RecoverRate</cite>, <strong>*h*</strong> the current block height, ![$h_0$](<a class="reference external" href="https://files.readme.io/db3ef5d-h0.PNG">https://files.readme.io/db3ef5d-h0.PNG</a>) the block height when the user uses credit last time and ![$u_{textrm{used}}$](<a class="reference external" href="https://files.readme.io/8a675b8-u-used.PNG">https://files.readme.io/8a675b8-u-used.PNG</a>) the amount of credit consumed after the user’s last transaction is paid by the account. Note that ![$C-c_{textrm{used}}$](<a class="reference external" href="https://files.readme.io/38a489c-c-cused.PNG">https://files.readme.io/38a489c-c-cused.PNG</a>) is the remaining credit after the last transaction is paid.
[block:api-header]
{</p>
<blockquote>
<div>“title”: “Master Account”</div></blockquote>
<p>}
[/block]
In VeChainThor, we introduce the concept of the master account to make it easier for dApp owners to use MPP and manage their dApps. Specifically, every account, including a smart contract, can have a <em>Master</em> account which is allowed by the system to register/remove <em>Users</em>, set a credit plan, and select the active <em>Sponsor</em> for the account. Note that the account that deploys a smart contract becomes the <em>Master</em> of the contract by default. A normal account can also set its <em>Master</em> through calling function <cite>setMaster</cite> implemented in the built-in contract <cite>Prototype</cite>. We will describe the implementation of MPP shortly.</p>
<p>In practice, we may most likely build a dapp based on multiple smart contracts. Each contract may have its own <em>Users</em> and be sponsored by multiple <em>Sponsors</em>. How to manage these accounts suddenly becomes a challenging task the dapp owner has to think about. With the <em>Master</em> mechanism and built-in contract <cite>Prototype</cite>, the owner does not have to implement anything on the contract code level to user MPP. He/she can now use even a single <em>Master</em> to manage all the contracts through calling functions of contract <cite>Prototype</cite>.
[block:api-header]
{</p>
<blockquote>
<div>“title”: “MPP Implementation”</div></blockquote>
<p>}
[/block]
The multi-party payment protocol is implemented by the built-in smart contract <cite>Prototype</cite> deployed at <cite>0x000000000000000000000050726f746f74797065</cite> in the genesis block of VeChainThor.</p>
<p>#### Functions related to <em>User</em></p>
<p><cite>isUser</cite></p>
<p>Check whether an account is a registered <em>User</em> of another account.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>address _self</cite>: account address</li>
<li><cite>address _user</cite>: <em>User</em> address</li>
</ul>
<p>Return:</p>
<ul class="simple">
<li><cite>true</cite> if <cite>_user</cite> is a <em>User</em> of <cite>_self</cite> or <cite>false</cite> otherwise</li>
</ul>
<hr class="docutils" />
<p><cite>addUser</cite> / <cite>removeUser</cite></p>
<p>Add / remove a <em>User</em> for an account. The transaction sender has to be the account itself or its current <em>Master</em>.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>address _self</cite>: account address</li>
<li><cite>address _user</cite>: <em>User</em> address</li>
</ul>
<p>#### Functions related to the <em>credit plan</em></p>
<p><cite>creditPlan</cite></p>
<p>Get the credit plan associated with an account.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>address _self</cite>: account address</li>
</ul>
<p>Return:</p>
<ul class="simple">
<li><cite>uint256 credit</cite>: maximum amount of credit (VTHO in wei) allowed for each  <em>User</em> of the account</li>
<li><cite>uint256 recoveryRate</cite>: amount of credit (VTHO in wei) generated per block for  each <em>User</em> of the account</li>
</ul>
<hr class="docutils" />
<p><cite>setCreditPlan</cite></p>
<p>Set a credit plan for an account. The transaction sender has to be either the account itself and its current <em>Master</em>.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>address _self</cite>: account address</li>
<li><cite>uint256 credit</cite>: maximum amount of credit (VTHO in wei) allowed for each  <em>User</em> of the account</li>
<li><cite>uint256 recoveryRate</cite>: amount of credit (VTHO in wei) generated per block for  each <em>User</em> of the account</li>
</ul>
<hr class="docutils" />
<p><cite>userCredit</cite></p>
<p>Get the available credit for a particular <em>User</em> of an account.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>address _self</cite>: account address</li>
<li><cite>address _user</cite>: <em>User</em> address</li>
</ul>
<p>Return:</p>
<ul class="simple">
<li><cite>uint256</cite>: available credit (VTHO in wei) for the <em>User</em></li>
</ul>
<p>#### Functions related <em>Master</em></p>
<p><cite>master</cite></p>
<p>Get the <em>Master</em> address of the given account address.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>address _self</cite>: account address</li>
</ul>
<p>Return:</p>
<ul class="simple">
<li><cite>address</cite>: address of the <em>Master</em> of <cite>_self</cite>.</li>
</ul>
<hr class="docutils" />
<p><cite>setMaster</cite></p>
<p>Set the <em>Master</em> for a particular account. The transaction sender has to be either the account itself or its current <em>Master</em>.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>address _self</cite>: account address</li>
<li><cite>address _newMaster</cite>: address of the new <em>Master</em> of <cite>_self</cite></li>
</ul>
<p>#### Functions related to <em>Sponsor</em></p>
<p><cite>sponsor</cite> / <cite>unsponsor</cite></p>
<p>Sponsor / unsponsor an account. The transaction sender has to be the <em>Sponsor</em> account.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>address _self</cite>: address of the account to be sponsored / unsponsored</li>
</ul>
<hr class="docutils" />
<p><cite>isSponsor</cite></p>
<p>Check whether an input account is a <em>Sponsor</em> of another account.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>address _self</cite>: account address</li>
<li><cite>address _sponsor</cite>: <em>Sponsor</em> address</li>
</ul>
<p>Return:</p>
<ul class="simple">
<li><cite>true</cite> if <cite>_sponsor</cite> is a <em>Sponsor</em> of <cite>_self</cite></li>
</ul>
<hr class="docutils" />
<p><cite>selectSponsor</cite></p>
<p>Select a <em>Sponsor</em>. The transaction sender has to be either the sponsored account or its <em>Master</em>.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>address _self</cite>: account address</li>
<li><cite>address _sponsor</cite>: <em>Sponsor</em> address</li>
</ul>
<hr class="docutils" />
<p><cite>currentSponsor</cite></p>
<p>Get the current active <em>Sponsor</em>.</p>
<p>Input:</p>
<ul class="simple">
<li><cite>address _self</cite>: account address</li>
</ul>
<p>Return:</p>
<ul class="simple">
<li><cite>address</cite>: address of the current active <em>Sponsor</em> of <cite>_self</cite>.</li>
</ul>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, VeChain Developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>